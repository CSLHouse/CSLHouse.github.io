{"meta":{"title":"借我一支烟","subtitle":"个人博客","description":null,"author":"Lin","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"初识lua-protobuf","slug":"初识lua-protobuf","date":"2019-01-23T07:25:07.000Z","updated":"2019-01-23T07:49:43.492Z","comments":true,"path":"2019/01/23/初识lua-protobuf/","link":"","permalink":"http://yoursite.com/2019/01/23/初识lua-protobuf/","excerpt":"","text":"资源下载源代码网址 lua-protobuf源代码文档 lua-protobuf源代码下载 Git Clone代码到本地: 复制代码 git clone http://www.github.com/starwing/lua-protobuf Subversion代码到本地: 复制代码 svn co –depth empty http://www.github.com/starwing/lua-protobuf Checked out revision 1. cd repo svn up trunk 用法protoc 模块函数返回描述 1234567891011121314protoc.new() Proroc对象 创建新的编译器实例protoc.reload() true 将所有google标准消息重新加载到 pb 模块中p:parse(string) 表格 将架构转换为 DescriptorProto 表p:parsefile(string) 表格 类似 p:parse()，但接受文件名p:compile(string) 字符串 将架构转换为二进制 *.pb 格式数据p:compilefile(string) 字符串 类似 p:compile()，但接受文件名p:load(string) true 将架构加载到 pb 模块中p:loadfile(string) true 类似 pb:loadfile()，但接受文件名p.loaded 表格 包含所有已经解析的DescriptorProto 表p.paths 表格 表包含导入搜索目录p.unknown_module 请参见下面 处理架构导入错误p.unknown_type 请参见下面 处理架构中的未知类型p.include_imports bool 自动加载导入的Prototype要分析文本文件，你应该首先创建一个编译器实例： pb 模块pb 模块具有高级例程，可以用于 maniplate protobuf消息。 在下面的函数中，有几种类型具有特殊的含义： type: 指示protobuf消息类型的字符串，”.Foo” 表示未声明 package 语句的原始文件中的类型。 “foo.Foo” 表示原始文件中声明 package foo;的类型 data: 可以是字符串，pb.slice 值或者 pb.buffer 值。 iterator: 可以在 Lua for in 语句中使用的函数，e.g. 复制代码for name in pb.types() doprint(name)end当遇到错误时，所有函数都返回 nil, errmsg 。函数返回描述 123456789101112131415161718pb.clear() 无 清除所有类型pb.clear(type) 无 删除特定类型pb.load(data) true 将二进制模式数据加载到 pb 模块中pb.loadfile(string) true pb.load() 相同，但接受文件名pb.encode(type, table) 字符串 将消息表编码为二进制形式pb.encode(type, table, b) 缓冲区 将消息表编码为二进制形式以缓冲pb.decode(type, data) 表格 将二进制消息解码为Lua表pb.decode(type, data, table) 表格 将二进制消息解码为给定的Lua表pb.pack(fmt,.. .) 字符串 buffer.pack() 相同但返回字符串pb.unpack(data, fmt,.. .) 值。 slice.unpack() 相同但接受数据pb.types() 迭代器 迭代 pb 模块中的所有类型pb.type(type) 请参见下面 返回特定类型的信息pb.fields(type) 迭代器 迭代消息中的所有字段pb.field(type, string) 请参见下面 返回类型特定字段的信息pb.enum(type, string) 号码 按名称获取 enum的值pb.enum(type, number) 字符串 按值获取 enum的名称pb.defaults(type[, table]) 表格 获取类型的默认表pb.option(string) 字符串 将选项设置为解码器/编码器 你可以使用 pb.(type|field)s 函数来检索已经加载消息的类型信息。 pb.type() 为指定类型返回多个信息： 名称：类型的完整qualitier名称，比如 。package 。typename”basename: 没有软件包前缀的类型名称，比如”typename””：”|”枚举”|”消息” 类型是否为map_entry类型，enum 类型或者消息类型。pb.types() 返回一个迭代器，如所有消息类型上的调用 pb.type() 。 print(pb.type”MyType”)– list all types that loaded into pbfor name, basename, type in pb.types() doprint(name, basename, type)end pb.field() 为一种类型返回指定字段的信息： 名称：字段名称编号：架构中的字段数类型：字段类型默认值：如果没有默认值，则为 nil可选”|”重复”|”：字段标签，可选或者重复，要求不支持如果这是一个字段，这是一个名称和索引然后 pb.fields() 迭代消息中的所有字段： print(pb.field(“MyType”, “the_first_field”))– notice that you needn’t receive all return values from iteratorfor name, number, type in pb.fields”MyType”doprint(name, number, type)end pb.enum() 映射来自 enum 名称和值： protoc:load[[enum Color { Red = 1; Green = 2; Blue = 3 }]]print(pb.enum(“Color”, “Red”)) –&gt; 1print(pb.enum(“Color”, 2)) –&gt;”Green” 使用 pb.defaults()，你可以获得一个包含消息中所有默认值的表： check_load[[ message TestDefault { optional int32 defaulted_int = 10 [ default = 777 ]; optional bool defaulted_bool = 11 [ default = true ]; optional string defaulted_str = 12 [ default =”foo” ]; optional float defaulted_num = 13 [ default = 0.125 ]; } ]]print(require”serpent”.block(pb.defaults”TestDefault”))– output:– {– defaulted_bool = true,– defaulted_int = 777,– defaulted_num = 0.125,– defaulted_str =”foo”– } –[[table: 0x7f8c1e52b050]] 转载自：lua-protobuf,使用protobuf得Lua模块","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"lua","slug":"lua","permalink":"http://yoursite.com/tags/lua/"},{"name":"lua-protobuf","slug":"lua-protobuf","permalink":"http://yoursite.com/tags/lua-protobuf/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"Centos7搭建svn服务器","slug":"Centos7搭建svn服务器","date":"2019-01-09T10:45:39.000Z","updated":"2019-01-09T11:09:40.527Z","comments":true,"path":"2019/01/09/Centos7搭建svn服务器/","link":"","permalink":"http://yoursite.com/2019/01/09/Centos7搭建svn服务器/","excerpt":"","text":"安装SV可参考 ##= 启动svnsvnserve -d -r /opt/svn/glory/ 关闭svnps aux | grep svnkill -9 [UID] 客户端连接svnsvn://192.168.1.10/Client 注：Client是glory下的子目录","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"},{"name":"SVN","slug":"SVN","permalink":"http://yoursite.com/tags/SVN/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-01-09T09:50:41.384Z","updated":"2019-01-09T09:50:41.384Z","comments":true,"path":"2019/01/09/hello-world/","link":"","permalink":"http://yoursite.com/2019/01/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[],"keywords":[]},{"title":"CentOS下编译安装shadowsocks-libev","slug":"CentOS下编译安装shadowsocks-libev","date":"2018-11-06T09:25:45.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/11/06/CentOS下编译安装shadowsocks-libev/","link":"","permalink":"http://yoursite.com/2018/11/06/CentOS下编译安装shadowsocks-libev/","excerpt":"","text":"安装 编译环境准备&amp;安装依赖包 yum install -y gcc automake autoconf libtool make build-essential autoconf libtool asciidoc xmlto libsodium libev-devel udns-devel yum install -y curl curl-devel unzip zlib-devel openssl-devel perl perl-devel cpio expat-devel gettext-devel 下载源码 git clone https://github.com/shadowsocks/shadowsocks-libev.git 开始编译 cd shadowsocks-libev ./autogen.sh ./configure –prefix=/usr &amp;&amp; make make install 准备必须的文件 mkdir -p /etc/shadowsocks-libev cp ./debian/shadowsocks-libev.init /etc/init.d/shadowsocks-libev cp ./debian/shadowsocks-libev.default /etc/default/shadowsocks-libev cp ./debian/shadowsocks-libev.service /lib/systemd/system/ cp ./debian/config.json /etc/shadowsocks-libev/config.json chmod +x /etc/init.d/shadowsocks-libev 编辑配置文件 vim /etc/shadowsocks-libev/config.json 启动服务 service shadowsocks-libev start FAQ 如果执行./autogen.sh时出现下列错误： configure.ac:309: error: required file ‘libcork/Makefile.in’ not found configure.ac:309: error: required file ‘libipset/Makefile.in’ not found 请初始化git库 git submodule init &amp;&amp; git submodule update 如果执行./configure –prefix=/usr出现下列错误 configure: error: mbed TLS libraries not found. 请安装TLS开发包 yum install -y mbedtls-devel 若提示：没有可用软件包 mbedtls-devel。请执行以下命令再重新安装： yum install epel-release yum update yum install mbedtls-devel","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://yoursite.com/tags/centos/"},{"name":"shadowsocks-libev","slug":"shadowsocks-libev","permalink":"http://yoursite.com/tags/shadowsocks-libev/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"mac使用ssh连接远程服务器并实现文件上传下砸","slug":"mac使用ssh连接远程服务器并实现文件上传下砸","date":"2018-08-20T10:54:41.000Z","updated":"2019-01-09T09:50:41.384Z","comments":true,"path":"2018/08/20/mac使用ssh连接远程服务器并实现文件上传下砸/","link":"","permalink":"http://yoursite.com/2018/08/20/mac使用ssh连接远程服务器并实现文件上传下砸/","excerpt":"","text":"使用ssh连接远程主机ssh username@192.168.100.100 其中，username是登录用户名，@后接ip地址，点击确定之后输入密码即连接到远程主机。要查看当前有多少个处于登录状态的用户，可以使用who命令查看。 使用scp命令实现上传下载1.从服务器上下载文件 scp username@servername:/path/filename /Users/mac/Desktop（本地目录）例如: scp root@123.207.170.40:/root/test.txt /Users/mac/Desktop就是将服务器上的/root/test.txt下载到本地的/Users/mac/Desktop目录下。注意两个地址之间有空格！ 2.上传本地文件到服务器 scp /path/filename username@servername:/path ;例如 scp /Users/mac/Desktop/test.txt root@123.207.170.40:/root/ 3.从服务器下载整个目录 scp -r username@servername:/root/（远程目录） /Users/mac/Desktop（本地目录）例如: scp -r root@192.168.0.101:/root/ /Users/mac/Desktop/ 4.上传目录到服务器 scp -r local_dir username@servername:remote_dir例如： scp -r test root@192.168.0.101:/root/ 把当前目录下的test目录上传到服务器的/root/ 目录 注：目标服务器要开启写入权限。","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"django","slug":"django","date":"2018-08-17T03:54:16.000Z","updated":"2019-01-09T09:50:41.384Z","comments":true,"path":"2018/08/17/django/","link":"","permalink":"http://yoursite.com/2018/08/17/django/","excerpt":"","text":"开启新项目创建项目cd 到一个你想放置你代码的目录，然后运行以下命令： $ django-admin startproject mysite 运行： $ python manage.py runserver 更换端口： $ python manage.py runserver 8080 创建应用应用是一个专门做某件事的网络应用程序——比如博客系统，或者公共记录的数据库，或者简单的投票程序。项目则是一个网站使用的配置和应用的集合。项目可以包含很多个应用。应用可以被很多个项目使用。 manage.py 所在的目录下，运行命令 $ python manage.py startapp polls 编写视图在 polls 目录里新建一个 urls.py 文件，输入如下代码： from django.urls import path from . import views urlpatterns = [ path(&apos;&apos;, views.index, name=&apos;index&apos;), ] 下一步是要在根 URLconf 文件中指定我们创建的 polls.urls 模块。在 mysite/urls.py 文件的 urlpatterns 列表里插入一个 include()， 如下： from django.contrib import admin from django.urls import include, path urlpatterns = [ path(&apos;polls/&apos;, include(&apos;polls.urls&apos;)), path(&apos;admin/&apos;, admin.site.urls), ] path() 参数 route route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。 这些准则不会匹配 GET 和 POST 参数或域名。例如，URLconf 在处理请求 https://www.example.com/myapp/ 时，它会尝试匹配 myapp/ 。处理请求 https://www.example.com/myapp/?page=3 时，也只会尝试匹配 myapp/。 view 当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。 kwargs 任意个关键字参数可以作为一个字典传递给目标视图函数。 name 为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。 数据库配置打开 mysite/settings.py，这个配置文件通常使用 SQLite 作为默认数据库。 如果想使用其他数据库，需要安装合适的database bindings，然后改变设置文件中 DATABASES ‘default’ 项目中的一些键值： ENGINE 可选值有’django.db.backends.sqlite3’，’django.db.backends.postgresql’，’django.db.backends.mysql’，或 ‘django.db.backends.oracle’。其它 可用后端。 NAME - 数据库的名称。 如果使用的是SQLite，数据库将是你电脑上的一个文件，在这种情况下， NAME 应该是此文件的绝对路径，包括文件名。默认值 os.path.join(BASE_DIR, ‘db.sqlite3’) 将会把数据库文件储存在项目的根目录。 如果你不使用 SQLite，则必须添加一些额外设置，比如 USER 、 PASSWORD 、 HOST 等等。想了解更多数据库设置方面的内容，请看文档：DATABASES 。 创建模型模型 - 也就是数据库结构设计和附加的其它元数据。 from django.db import models class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField(&apos;date published&apos;) class Choice(models.Model): question = models.ForeignKey(Question, on_delete=models.CASCADE) choice_text = models.CharField(max_length=200) votes = models.IntegerField(default=0) 激活模型上面的一小段用于创建模型的代码,Django 可以： 为这个应用创建数据库 schema（生成 CREATE TABLE 语句）。 创建可以与 Question 和 Choice 对象进行交互的 Python 数据库 API。 但是首先得把 polls 应用安装到项目里。 因为 PollsConfig 类写在文件 polls/apps.py 中，所以它的点式路径是 ‘polls.apps.PollsConfig’。在文件 mysite/settings.py 中 INSTALLED_APPS 子项添加点式路径后，它看起来像这样： INSTALLED_APPS = [ &apos;polls.apps.PollsConfig&apos;, &apos;django.contrib.admin&apos;, &apos;django.contrib.auth&apos;, &apos;django.contrib.contenttypes&apos;, &apos;django.contrib.sessions&apos;, &apos;django.contrib.messages&apos;, &apos;django.contrib.staticfiles&apos;, ] 现在你的 Django 项目会包含 polls 应用。接着运行下面的命令： python manage.py makemigrations polls 写一个真正有用的视图每个视图必须要做的只有两件事：返回一个包含被请求页面内容的 HttpResponse 对象，或者抛出一个异常，比如 Http404 。 首先，在 polls 目录里创建一个 templates 目录。Django 将会在这个目录里查找模板文件。 默认的设置文件设置了 DjangoTemplates 后端，并将 APP_DIRS 设置成了 True。这一选项将会让 DjangoTemplates 在每个 INSTALLED_APPS文件夹中寻找 “templates” 子目录。 在刚刚创建的 templates 目录里，再创建一个目录 polls，然后在其中新建一个文件 index.html 。换句话说，你的模板文件的路径应该是 polls/templates/polls/index.html 。因为 Django 会寻找到对应的 app_directories ，所以你只需要使用 polls/index.html 就可以引用到这一模板了。 自定义 应用 的界面和风格首先，在你的 polls 目录下创建一个名为 static 的目录。将以下代码放入样式表(polls/static/polls/style.css)： li a { color: green; } 下一步，在 polls/templates/polls/index.html 的文件头添加以下内容： {% load static %} &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;{% static 'polls/style.css' %}&quot;&gt; {% static %} 模板标签会生成静态文件的绝对路径。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"},{"name":"django","slug":"django","permalink":"http://yoursite.com/tags/django/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"centos7安装mysql","slug":"centos7安装mysql","date":"2018-08-10T10:02:20.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/08/10/centos7安装mysql/","link":"","permalink":"http://yoursite.com/2018/08/10/centos7安装mysql/","excerpt":"","text":"环境Linux版本：5.7 安装下载地址yum install -y mysql*注：一开始一直报‘Failed to start mysqld.service: Unit not found.’网上查找方法，好一通折腾，原来没安装mysql-community-server。 启动执行 service mysqld start 通过如下命令找到mysql root初始密码 grep &apos;temporary password&apos; /var/log/mysqld.log 登录mysql，修改密码执行 mysql -uroot -p 然后输入密码登录时，一直如下错误： ERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: YES) 一般这个错误是由密码错误引起，解决的办法自然就是重置密码解决方案如下： 停止mysql数据库：service mysqld stop或systemctl stop mysqld 用以下命令启动MySQL，以不检查权限的方式启动： mysqld –skip-grant-tables &amp; 此时又报了一个错误：2018-02-01T02:52:55.093724Z 0 [ERROR] Fatal error: Please read “Security” section of the manual to find out how to run mysqld as root! 执行命令：mysqld –user=root –skip-grant-tables &amp; 登录mysql：service mysqld startmysql -uroot或mysql 更新root密码 mysql5.7以下版本：UPDATE mysql.user SET Password=PASSWORD(‘123456’) where USER=’root’; mysql5.7版本：UPDATE mysql.user SET authentication_string=PASSWORD(‘123456’) where USER=’root’; 5.刷新权限：flush privileges; 6.退出mysql：exit或quit 7.使用root用户重新登录mysql mysql -uroot -p Enter password:&lt;输入新设的密码123456&gt;","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://yoursite.com/tags/centos/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"搭建自己的翻墙服务器","slug":"搭建自己的翻墙服务器","date":"2018-08-07T15:07:17.000Z","updated":"2019-01-09T09:50:41.384Z","comments":true,"path":"2018/08/07/搭建自己的翻墙服务器/","link":"","permalink":"http://yoursite.com/2018/08/07/搭建自己的翻墙服务器/","excerpt":"","text":"所需工具 亚马逊服务器 securecrt SwitchyOmega 注册激活网上搜’亚马逊服务器注册激活‘，教程很多。 亚马逊主机亚马逊开通了AWS云服务，可以通过申请亚马逊aws试用资格享受12个月免费主机试用资格。不过要注意日期，超过12个月之后就要收费了，到时候再考虑其他渠道，比如阿里云。。 创建实例打开亚马逊aws云服务，自己注册，注册方法自行百度，注意区域选择离中国近的地区 进入【EC2】&gt; 云虚拟服务器，在出现的页面点击创建实例：【启动实例】—选择免费实例 进入Amazon系统映像，选择linux版本、64位 进入实例套餐（选择免费类型），点击启动实例 创建密钥对，一定下载保存 启动实例 SecureCRT访问Amazon EC2主机 上传xxx.pem文件到一个linux系统下，修改其权限为600,。命令 chmod 600 xxx.pem 改写密钥格式为 OpenSSH，命令 ssh-keygen -p -f xxx.pem（如果询问passphrase直接回车） 生成公密钥 .pub 文件 命令 ssh-keygen -e -f xxx.pem &gt; xxx.pem.pub 在SecureCRT中新建连接，协议选择ssh2 ，主机名填写public dns（这个地址EC2的控制台中会提供），用户名填写ec2-user 。 右键点击属性，选中’SSH2’,再选择鉴权（Authentication）中的公钥（PublicKey），选中之后右边的属性（Properties）才可选择，点击属性（Properties），选中3生成的共钥，确认即可。如图：注：公钥和密钥在同一个目录下。 右键属性，选择‘端口转发(Por Forwarding)’–‘添加(Add)’，名字(Name)填‘socks5’,端口自定义（比如1888），然后勾选上‘Dynamic forwarding using SOCKS 4 or 5’.如图： 在SecureCRT连接的列表中找到刚创建的连接，右键属性，左边树中选择PortForwarding,点击添加，name填socks5,Port自定义，比如1888 配置SwitchyOmega下载安装点击 Github-SwitchyOmega，下载页面有详细的安装教程，仔细看一下就好。； 配置 Shadowsocks 情景模式 打开 Chrome， 点击右上角的 图标，再点击 选项。 点击左侧的 新建情景模式，输入情景模式名称 Shadowsocks【自己任意设置名称】，类型选择第一个代理服务器。创建完成后做如下配置：注：代理端口是上一项第（6）条填的端口号 保存后你就可以通过这个情景模式科学上网了 配置自动切换模式点击左侧的 自动切换，或者自己新建情景模式，类型选择第二个 自动切换模式。然后做如下配置： 切换规则 是在访问 条件设置 的域名时候使用后面设置的 情景模式。比如图中我设置 .google.com 和 .github.com 使用 Shadowsocks 情景模式【刚刚创建的那个情景模式】。我们可以点击 添加条件 来添加自己的规则。遇到资源未加载的情况时，点击添加条件，即是添加切换规则 将图中 规则列表规则 前面的框打√，再将后面的 情景模式 设置为 Shadowsocks，意思是规则列表中的内容，我们使用 Shadowsocks 情景模式。然后 规则列表设置 中： 规则列表格式： AutoProxy； 规则列表网址：https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt -这样设置完成 规则列表规则 后就不需要在切换规则中一个一个添加条件了。 openwrt翻墙利用openwrt可打造一台翻墙路由器，也可搭建一台翻墙虚拟机","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"翻墙","slug":"翻墙","permalink":"http://yoursite.com/tags/翻墙/"},{"name":"securecrt","slug":"securecrt","permalink":"http://yoursite.com/tags/securecrt/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"linux常用命令","slug":"linux常用命令","date":"2018-08-03T06:10:54.000Z","updated":"2019-01-09T09:50:41.384Z","comments":true,"path":"2018/08/03/linux常用命令/","link":"","permalink":"http://yoursite.com/2018/08/03/linux常用命令/","excerpt":"","text":"mkdir 创建文件夹/目录命令参数： -m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask -p, --parents 可以是一个路径名称。 此时若路径中的某些目录尚不存在,加上此选项后, 系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; -v, --verbose 每次创建新目录都显示信息 --help 显示此帮助信息并退出 --version 输出版本信息并退出 cp 复制cp命令语法 cp [options] sourcedir destdir 参数说明： -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。 -d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。 -f：覆盖已经存在的目标文件而不给出提示。 -i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答&quot;y&quot;时目标文件将被覆盖。 -p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。 -r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。 -l：不复制文件，只是生成链接文件。 解压缩文件夹tar命令 解包：tar zxvf FileName.tar 打包：tar czvf FileName.tar DirName zip命令 解压：unzip FileName.zip 压缩：zip FileName.zip DirName rm 删除文件夹rm -rf 目录名字 -r 向下递归，不管有多少级目录，一并删除 -f 直接强行删除，没有任何提示 删除文件夹实例： rm -rf /var/log/httpd 删除文件使用实例： rm -f /var/log/httpd/access.log 文件和目录cd /home 进入 &apos;/ home&apos; 目录&apos; cd .. 返回上一级目录 cd ../.. 返回上两级目录 cd 进入个人的主目录 cd ~user1 进入个人的主目录 cd - 返回上次所在的目录 pwd 显示工作路径 ls 查看目录中的文件 ls -F 查看目录中的文件 ls -l 显示文件和目录的详细资料 ls -a 显示隐藏文件 ls *[0-9]* 显示包含数字的文件名和目录名 tree 显示文件和目录由根目录开始的树形结构(1) lstree 显示文件和目录由根目录开始的树形结构(2) mkdir dir1 创建一个叫做 &apos;dir1&apos; 的目录&apos; mkdir dir1 dir2 同时创建两个目录 mkdir -p /tmp/dir1/dir2 创建一个目录树 rm -f file1 删除一个叫做 &apos;file1&apos; 的文件&apos; rmdir dir1 删除一个叫做 &apos;dir1&apos; 的目录&apos; rm -rf dir1 删除一个叫做 &apos;dir1&apos; 的目录并同时删除其内容 rm -rf dir1 dir2 同时删除两个目录及它们的内容 mv dir1 new_dir 重命名/移动 一个目录 cp file1 file2 复制一个文件 cp dir/* . 复制一个目录下的所有文件到当前工作目录 cp -a /tmp/dir1 . 复制一个目录到当前工作目录 cp -a dir1 dir2 复制一个目录 ln -s file1 lnk1 创建一个指向文件或目录的软链接 ln file1 lnk1 创建一个指向文件或目录的物理链接 文件搜索find / -name file1 从 &apos;/&apos; 开始进入根文件系统搜索文件和目录 find / -user user1 搜索属于用户 &apos;user1&apos; 的文件和目录 find /home/user1 -name \\*.bin 在目录 &apos;/ home/user1&apos; 中搜索带有&apos;.bin&apos; 结尾的文件 find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件 find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件 find / -name \\*.rpm -exec chmod 755 &apos;{}&apos; \\; 搜索以 &apos;.rpm&apos; 结尾的文件并定义其权限 find / -xdev -name \\*.rpm 搜索以 &apos;.rpm&apos; 结尾的文件，忽略光驱、捷盘等可移动设备 locate \\*.ps 寻找以 &apos;.ps&apos; 结尾的文件 - 先运行 &apos;updatedb&apos; 命令 whereis halt 显示一个二进制文件、源码或man的位置 which halt 显示一个二进制文件或可执行文件的完整路径 打包和压缩文件bunzip2 file1.bz2 解压一个叫做 &apos;file1.bz2&apos;的文件 bzip2 file1 压缩一个叫做 &apos;file1&apos; 的文件 gunzip file1.gz 解压一个叫做 &apos;file1.gz&apos;的文件 gzip file1 压缩一个叫做 &apos;file1&apos;的文件 gzip -9 file1 最大程度压缩 rar a file1.rar test_file 创建一个叫做 &apos;file1.rar&apos; 的包 rar a file1.rar file1 file2 dir1 同时压缩 &apos;file1&apos;, &apos;file2&apos; 以及目录 &apos;dir1&apos; rar x file1.rar 解压rar包 unrar x file1.rar 解压rar包 tar -cvf archive.tar file1 创建一个非压缩的 tarball tar -cvf archive.tar file1 file2 dir1 创建一个包含了 &apos;file1&apos;, &apos;file2&apos; 以及 &apos;dir1&apos;的档案文件 tar -tf archive.tar 显示一个包中的内容 tar -xvf archive.tar 释放一个包 tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下 tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包 tar -jxvf archive.tar.bz2 解压一个bzip2格式的压缩包 tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包 tar -zxvf archive.tar.gz 解压一个gzip格式的压缩包 zip file1.zip file1 创建一个zip格式的压缩包 zip -r file1.zip file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包 unzip file1.zip 解压一个zip格式压缩包 YUM 软件包升级器 - （Fedora, RedHat及类似系统）yum install package_name 下载并安装一个rpm包 yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系 yum update package_name.rpm 更新当前系统中所有安装的rpm包 yum update package_name 更新一个rpm包 yum remove package_name 删除一个rpm包 yum list 列出当前系统中安装的所有包 yum search package_name 在rpm仓库中搜寻软件包 yum clean packages 清理rpm缓存删除下载的包 yum clean headers 删除所有头文件 yum clean all 删除所有缓存的包和头文件 文本处理cat file1 file2 ... | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT cat file1 | command( sed, grep, awk, grep, etc...) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中 cat file1 | command( sed, grep, awk, grep, etc...) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中 grep Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找关键词&quot;Aug&quot; grep ^Aug /var/log/messages 在文件 &apos;/var/log/messages&apos;中查找以&quot;Aug&quot;开始的词汇 grep [0-9] /var/log/messages 选择 &apos;/var/log/messages&apos; 文件中所有包含数字的行 grep Aug -R /var/log/* 在目录 &apos;/var/log&apos; 及随后的目录中搜索字符串&quot;Aug&quot; sed &apos;s/stringa1/stringa2/g&apos; example.txt 将example.txt文件中的 &quot;string1&quot; 替换成 &quot;string2&quot; sed &apos;/^$/d&apos; example.txt 从example.txt文件中删除所有空白行 sed &apos;/ *#/d; /^$/d&apos; example.txt 从example.txt文件中删除所有注释和空白行 echo &apos;esempio&apos; | tr &apos;[:lower:]&apos; &apos;[:upper:]&apos; 合并上下单元格内容 sed -e &apos;1d&apos; result.txt 从文件example.txt 中排除第一行 sed -n &apos;/stringa1/p&apos; 查看只包含词汇 &quot;string1&quot;的行 sed -e &apos;s/ *$//&apos; example.txt 删除每一行最后的空白字符 sed -e &apos;s/stringa1//g&apos; example.txt 从文档中只删除词汇 &quot;string1&quot; 并保留剩余全部 sed -n &apos;1,5p;5q&apos; example.txt 查看从第一行到第5行内容 sed -n &apos;5p;5q&apos; example.txt 查看第5行 sed -e &apos;s/00*/0/g&apos; example.txt 用单个零替换多个零 cat -n file1 标示文件的行数 cat example.txt | awk &apos;NR%2==1&apos; 删除example.txt文件中的所有偶数行 echo a b c | awk &apos;{print $1}&apos; 查看一行第一栏 echo a b c | awk &apos;{print $1,$3}&apos; 查看一行的第一和第三栏 paste file1 file2 合并两个文件或两栏的内容 paste -d &apos;+&apos; file1 file2 合并两个文件或两栏的内容，中间用&quot;+&quot;区分 sort file1 file2 排序两个文件的内容 sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份) sort file1 file2 | uniq -u 删除交集，留下其他的行 sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件) comm -1 file1 file2 比较两个文件的内容只删除 &apos;file1&apos; 所包含的内容 comm -2 file1 file2 比较两个文件的内容只删除 &apos;file2&apos; 所包含的内容 comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"命令","slug":"命令","permalink":"http://yoursite.com/tags/命令/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"centos7配置网关","slug":"centos7配置网关","date":"2018-08-02T09:37:29.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/08/02/centos7配置网关/","link":"","permalink":"http://yoursite.com/2018/08/02/centos7配置网关/","excerpt":"","text":"起源搭建虚拟机并配置centos7之后，在主机终端采用ssh root@192.168.131.141方式连接虚拟机，当访问公司内网，执行curl http://###下载资源，下载失败，错误显示’### port 443: “拒绝连接”‘, 配置网关一开始以为没配置网关，所以网上搜索了网关的配置方法，记录一下： 1、CentOS 修改DNS 修改对应网卡的DNS的配置文件 # vi /etc/resolv.conf 修改以下内容 nameserver 8.8.8.8 #google域名服务器 nameserver 8.8.4.4 #google域名服务器 2、CentOS 修改网关修改对应网卡的网关的配置文件 [root@centos]# vi /etc/sysconfig/network 修改以下内容NETWORKING=yes(表示系统是否使用网络，一般设置为yes。如果设为no，则不能使用网络，而且很多系统服务程序将无法启动)HOSTNAME=centos(设置本机的主机名，这里设置的主机名要和/etc/hosts中设置的主机名对应)GATEWAY=192.168.1.1(设置本机连接的网关的IP地址。例如，网关为10.0.0.2)3、CentOS 修改IP地址 修改对应网卡的IP地址的配置文件注：查看/etc/sysconfig/network-scripts下，是否已经有网卡位置文件，一个和使用ip addr命令查看ip第二条开头的名称一致的文件（我的是ens33） # vi /etc/sysconfig/network-scripts/ifcfg-eth0 修改以下内容 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=ens33 UUID=bfef954d-eca2-4096-947f-8c6faf5e44b0 DEVICE=ens33 ONBOOT=yes IPADDR=192.168.131.141 GATEWAY=192.168.131.2 NETMAK=255.255.255.0 NM_COTROLLED=no DNS1=8.8.8.8 4、重新启动网络配置 # service network restart 或 # /etc/init.d/network restart 解决问题请教高人才发现时时DNS写错了，与公司的dns不一致，执行vi /etc/resolv.conf ，添加nameserver 192.168.1.254之后成功","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"centos","slug":"centos","permalink":"http://yoursite.com/tags/centos/"},{"name":"linux","slug":"linux","permalink":"http://yoursite.com/tags/linux/"},{"name":"443","slug":"443","permalink":"http://yoursite.com/tags/443/"},{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/后端/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"ansible 应用","slug":"ansible应用","date":"2018-07-31T02:38:16.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/07/31/ansible应用/","link":"","permalink":"http://yoursite.com/2018/07/31/ansible应用/","excerpt":"","text":"链接地址：http://www.ansible.com.cn/docs/YAMLSyntax.html 环境创建 参考Python-配置虚拟环境,创建ansible的应用环境。 安装：pip install ansible 建立免密钥登陆为了避免Ansible下发指令时输入目标主机密码，通过证书签名达到SSH无密码是一个好的方案，推荐使用ssh-keygen与ssh-copy-id来实现快速证书的生成和公钥下发，其中ssh-keygen生成一对密钥，使用ssh-copy-id来下发生成的公钥。具体操作如下：生成管理主机得私钥和公钥 ssh-keygen -t rsa -b 2048 -P &apos;&apos; -f /root/.ssh/id_rsa 添加主机信息到主机清单中 #host 192.168.77.129 ansible_ssh_pass=1234567 192.168.77.130 ansible_ssh_pass=123456 ansible_ssh_pass密码如果一样的话，这里就不需要定义了。在运行ansible-playbook时 加上-k参数，就可以输入登陆密码 配置palybook - hosts: testhosts user: root tasks: - name: ssh-copy authorized_key: user=root key=&quot;{{ lookup('file', '/Users/tpw-dev/.ssh/id_rsa.pub') }}&quot; tags: sshkey 运行playbook ansible-playbook -i hosts ssh-addkey.yml 这样，管理节点的公钥就会添加到节点得authorized_keys文件中，再把主机清单里的ansible_ssh_pass去掉，执行ansible all -m ping 就不需要密码了。 Inventory(清单)文件Ansible 可同时操作属于一个组的多台主机,组和主机之间的关系通过 inventory 文件配置. 默认的文件路径为 /etc/ansible/hosts，在执行ansible-book命令时，也可通过执行-i选项制定inventory 文件。 Inventory 参数的说明 ansible_ssh_host 将要连接的远程主机名.与你想要设定的主机的别名不同的话,可通过此变量设置. ansible_ssh_port ssh端口号.如果不是默认的端口号,通过此变量设置. ansible_ssh_user 默认的 ssh 用户名 ansible_ssh_pass ssh 密码(这种方式并不安全,我们强烈建议使用 --ask-pass 或 SSH 密钥) ansible_sudo_pass sudo 密码(这种方式并不安全,我们强烈建议使用 --ask-sudo-pass) ansible_sudo_exe (new in version 1.8) sudo 命令路径(适用于1.8及以上版本) ansible_connection 与主机的连接类型.比如:local, ssh 或者 paramiko. Ansible 1.2 以前默认使用 paramiko.1.2 以后默认使用 &apos;smart&apos;,&apos;smart&apos; 方式会根据是否支持 ControlPersist, 来判断&apos;ssh&apos; 方式是否可行. ansible_ssh_private_key_file ssh 使用的私钥文件.适用于有多个密钥,而你不想使用 SSH 代理的情况. ansible_shell_type 目标系统的shell类型.默认情况下,命令的执行使用 &apos;sh&apos; 语法,可设置为 &apos;csh&apos; 或 &apos;fish&apos;. ansible_python_interpreter 目标主机的 python 路径.适用于的情况: 系统中有多个 Python, 或者命令路径不是&quot;/usr/bin/python&quot;,比如 \\*BSD, 或者 /usr/bin/python 不是 2.X 版本的 Python.我们不使用 &quot;/usr/bin/env&quot; 机制,因为这要求远程用户的路径设置正确,且要求 &quot;python&quot; 可执行程序名不可为 python以外的名字(实际有可能名为python26). 与 ansible_python_interpreter 的工作方式相同,可设定如 ruby 或 perl 的路径.... Playbooks 介绍playbook 由一个或多个 ‘plays’ 组成.它的内容是一个以 ‘plays’ 为元素的列表.在 ansible 中,play 的内容,被称为 tasks,即任务. 这里有一个 playbook,其中仅包含一个 play: --- - hosts: webservers vars: http_port: 80 max_clients: 200 remote_user: root tasks: - name: ensure apache is at the latest version yum: pkg=httpd state=latest - name: write the apache config file template: src=/srv/httpd.j2 dest=/etc/httpd.conf notify: - restart apache playbook基础主机与用户hosts 行的内容是一个或多个组或主机的 patterns,以逗号为分隔符 remote_user 就是账户名: --- - hosts: webservers remote_user: root Tasks 列表每一个 play 包含了一个 task 列表（任务列表）.一个 task 在其所对应的所有主机上（通过 host pattern 匹配的所有主机）执行完毕之后,下一个 task 才会执行.每个 task 的目标在于执行一个 moudle,modules 具有”幂等”性,意思是如果你再一次地执行 moudle,moudle 只会执行必要的改动,只会改变需要改变的地方.所以重复多次执行 playbook 也很安全.下面是一种基本的 task 的定义,service moudle 使用 key=value 格式的参数,这也是大多数 module 使用的参数格式: tasks: - name: make sure apache is running service: name=httpd state=running 比较特别的两个 modudle 是 command 和 shell ,它们不使用 key=value 格式的参数,而是这样: tasks: - name: disable selinux command: /sbin/setenforce 0 tasks可添加biaoqian(tags),这样在执行命令时可制定tasks如下： - name: Create Base folder file: path: &quot;{{baseDeployPathPrefix}}{{serverId}}&quot; state: directory tags: system - name: copy redis dir synchronize: src: redis-4.0.10 dest: &quot;{{baseDeployPathPrefix}}{{serverId}}&quot; tags: redis ansible-playbook -i test_hosts -e &quot;target=s1001&quot; -t createDB site.yml -t 后跟tags，这样就可以指定要执行的tasks Handlers: 在发生改变时执行的操作(当发生改动时）’notify’ actions 会在 playbook 的每一个 task 结束时被触发,而且即使有多个不同的 task 通知改动的发生, ‘notify’ actions 只会被触发一次. 这里有一个例子,当一个文件的内容被改动时,重启两个 services: - name: template configuration file template: src=template.j2 dest=/etc/foo.conf notify: - restart memcached - restart apache ‘notify’ 下列出的即是 handlers. Handlers 是由通知者进行 notify, 如果没有被 notify,handlers 不会执行. 这里是一个 handlers 的示例: handlers: - name: restart memcached service: name=memcached state=restarted - name: restart apache service: name=apache state=restarted handlers 会按照声明的顺序执行 提示与技巧如果想看到执行成功的 modules 的输出信息,使用 –verbose flag（否则只有执行失败的才会有输出信息）. 在执行一个 playbook 之前,想看看这个 playbook 的执行会影响到哪些 hosts,你可以这样做: ansible-playbook playbook.yml --list-hosts Roles一个项目的结构如下: site.yml webservers.yml fooservers.yml roles/ common/ files/ templates/ tasks/ handlers/ vars/ defaults/ meta/ webservers/ files/ templates/ tasks/ handlers/ vars/ defaults/ meta/ 一个 playbook 如下: --- - hosts: webservers roles: - common - webservers 这个 playbook 为一个角色 ‘x’ 指定了如下的行为： 如果 roles/x/tasks/main.yml 存在, 其中列出的 tasks 将被添加到 play 中 如果 roles/x/handlers/main.yml 存在, 其中列出的 handlers 将被添加到 play 中 如果 roles/x/vars/main.yml 存在, 其中列出的 variables 将被添加到 play 中 如果 roles/x/meta/main.yml 存在, 其中列出的 “角色依赖” 将被添加到 roles 列表中 (1.3 and later) 所有 copy tasks 可以引用 roles/x/files/ 中的文件，不需要指明文件的路径。 所有 script tasks 可以引用 roles/x/files/ 中的脚本，不需要指明文件的路径。 所有 template tasks 可以引用 roles/x/templates/ 中的文件，不需要指明文件的路径。 所有 include tasks 可以引用 roles/x/tasks/ 中的文件，不需要指明文件的路径。 如果你希望定义一些 tasks，让它们在 roles 之前以及之后执行，你可以这样做: --- - hosts: webservers pre_tasks: - shell: echo &apos;hello&apos; roles: - { role: some_role } tasks: - shell: echo &apos;still busy&apos; post_tasks: - shell: echo &apos;goodbye&apos; 值得指出的是,handlers 会在 ‘pre_tasks’, ‘roles’, ‘tasks’, 和 ‘post_tasks’ 之间自动执行. 如果你想立即执行所有的 handler 命令. tasks: - shell: some tasks go here - meta: flush_handlers - shell: some other tasks Ansible GalaxyAnsible Galaxy 是一个自由网站，网站提供所有类型的由社区开发的 roles，这对于实现你的自动化项目是一个很好的参考。网站提供这些 roles 的排名、查找以及下载。 Variables(变量)定义变量 在Inventory中定义变量 在playbook中定义变量 在文件和role中定义变量 使用变量: 关于Jinja2变量替换最基本的形式: template: src=foo.cfg.j2 dest=/foo.cfg YAML陷阱YAML语法要求如果值以开头的话我们需要将整行用双引号包起来.这是为了确认你不是想声明一个YAML字典. 这样是不行的: - hosts: app_servers vars: app_path: {{ base_path }}/22 你应该这么做: - hosts: app_servers vars: app_path: &quot;{{ base_path }}/22&quot; FactsFacts通过访问远程系统获取相应的信息. 一个例子就是远程主机的IP地址或者操作系统是什么. 使用以下命令可以查看哪些信息是可用的: ansible hostname -m setup 这会返回巨量的变量数据,默认是生成这些信息的，可以在playbook中这样引用远程系统的主机名 {{ ansible_nodename }} 关闭Facts - hosts: whatever gather_facts: no Fact缓存因为缓存的存在，从一个服务器引用另一个服务器的变量是可行的. {{ hostvars['asdf.example.com']['ansible_os_family'] }} 命令行中传递变量除了vars_prompt和vars_files也可以通过Ansible命令行发送变量.如果你想编写一个通用的发布playbook时则特别有用,你可以传递应用的版本以便部署: --- - hosts: &quot;{{ target }}&quot; gather_facts: false remote_user: root roles: - common - game ansible-playbook -i test_hosts -e &quot;target=s1001&quot; -t createDB site.yml 条件选择When 语句想忽略某一错误,通过执行成功与否来做决定,我们可以像这样: tasks: - command: /bin/false register: result ignore_errors: True - command: /bin/something when: result|failed - command: /bin/something_else when: result|success - command: /bin/still/something_else when: result|skipped 如果想查看哪些事件在某个特定系统中时允许的,可以执行以下命令: ansible hostname.example.com -m setup 有些时候你得到一个返回参数的值是一个字符串,并且你还想使用数学操作来比较它,那么你可以执行一下操作: tasks: - shell: echo &quot;only on Red Hat 6, derivatives, and later&quot; when: ansible_os_family == &quot;RedHat&quot; and ansible_lsb.major_release|int &gt;= 6 循环标准循环为了保持简洁,重复的任务可以用以下简写的方式: - name: add several users user: name={{ item.name }} state=present groups={{ item.groups }} with_items: - { name: &apos;testuser1&apos;, groups: &apos;wheel&apos; } - { name: &apos;testuser2&apos;, groups: &apos;root&apos; } 嵌套循环- name: give users access to multiple databases mysql_user: name={{ item[0] }} priv={{ item[1] }}.*:ALL append_privs=yes password=foo with_nested: - [ &apos;alice&apos;, &apos;bob&apos; ] - [ &apos;clientdb&apos;, &apos;employeedb&apos;, &apos;providerdb&apos; ] 对哈希表使用循环假如你有以下变量: --- users: alice: name: Alice Appleworth telephone: 123-456-7890 bob: name: Bob Bananarama telephone: 987-654-3210 你想打印出每个用户的名称和电话号码.你可以使用 with_dict 来循环哈希表中的元素: tasks: - name: Print phone records debug: msg=&quot;User {{ item.key }} is {{ item.value.name }} ({{ item.value.telephone }})&quot; with_dict: &quot;{{users}}&quot; 对文件列表使用循环 with_fileglob 可以以非递归的方式来模式匹配单个目录中的文件.如下面所示: --- - hosts: all tasks: # first ensure our target directory exists - file: dest=/etc/fooapp state=directory # copy each file over that matches the given pattern - copy: src={{ item }} dest=/etc/fooapp/ owner=root mode=600 with_fileglob: - /playbooks/files/fooapp/* 对并行数据集使用循环假设你通过某种方式加载了以下变量数据: --- alpha: [ &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos; ] numbers: [ 1, 2, 3, 4 ] 如果你想得到’(a, 1)’和’(b, 2)’之类的集合.可以使用’with_together’: tasks: - debug: msg=&quot;{{ item.0 }} and {{ item.1 }}&quot; with_together: - &quot;{{alpha}}&quot; - &quot;{{numbers}}&quot; 对子元素使用循环假设你想对一组用户做一些动作,比如创建这些用户,并且允许它们使用一组SSH key来登录. 如何实现那? 先假设你有按以下方式定义的数据,可以通过”vars_files”或”group_vars/all”文件加载: --- users: - name: alice authorized: - /tmp/alice/onekey.pub - /tmp/alice/twokey.pub mysql: password: mysql-password hosts: - &quot;%&quot; - &quot;127.0.0.1&quot; - &quot;::1&quot; - &quot;localhost&quot; privs: - &quot;*.*:SELECT&quot; - &quot;DB1.*:ALL&quot; - name: bob authorized: - /tmp/bob/id_rsa.pub mysql: password: other-mysql-password hosts: - &quot;db1&quot; privs: - &quot;*.*:SELECT&quot; - &quot;DB2.*:ALL&quot; 那么可以这样实现: - user: name={{ item.name }} state=present generate_ssh_key=yes with_items: &quot;{{users}}&quot; - authorized_key: &quot;user={{ item.0.name }} key=&apos;{{ lookup('file', item.1) }}&apos;&quot; with_subelements: - users - authorized 根据mysql hosts以及预先给定的privs subkey列表,我们也可以在嵌套的subkey中迭代列表: - name: Setup MySQL users mysql_user: name={{ item.0.user }} password={{ item.0.mysql.password }} host={{ item.1 }} priv={{ item.0.mysql.privs | join('/') }} with_subelements: - users - mysql.hosts 对整数序列使用循环with_sequence 可以以升序数字顺序生成一组序列.你可以指定起始值、终止值,以及一个可选的步长值. 指定参数时也可以使用key=value这种键值对的方式.如果采用这种方式,’format’是一个可打印的字符串. 数字值可以被指定为10进制,16进制(0x3f8)或者八进制(0600).负数则不受支持.请看以下示例: --- - hosts: all tasks: # create groups - group: name=evens state=present - group: name=odds state=present # create some test users - user: name={{ item }} state=present groups=evens with_sequence: start=0 end=32 format=testuser%02x # create a series of directories with even numbers for some reason - file: dest=/var/stuff/{{ item }} state=directory with_sequence: start=4 end=16 stride=2 # a simpler way to use the sequence plugin # create 4 groups - group: name=group{{ item }} state=present with_sequence: count=4 随机选择‘random_choice’功能可以用来随机获取一些值.它并不是负载均衡器(已经有相关的模块了).它有时可以用作一个简化版的负载均衡器,比如作为条件判断: - debug: msg={{ item }} with_random_choice: - &quot;go through the door&quot; - &quot;drink from the goblet&quot; - &quot;press the red button&quot; - &quot;do nothing&quot; Do-Until循环有时你想重试一个任务直到达到某个条件.比如下面这个例子: - action: shell /usr/bin/foo register: result until: result.stdout.find(&quot;all systems go&quot;) != -1 retries: 5 delay: 10 查找第一个匹配的文件这其实不是一个循环,但和循环很相似.如果你想引用一个文件,而该文件是从一组文件中根据给定条件匹配出来的.这组文件中部分文件名由变量拼接而成.针对该场景你可以这样做: - name: INTERFACES | Create Ansible header for /etc/network/interfaces template: src={{ item }} dest=/etc/foo.conf with_first_found: - &quot;{{ansible_virtualization_type}}_foo.conf&quot; - &quot;default_foo.conf&quot; 该功能还有一个更完整的版本,可以配置搜索路径.请看以下示例: - name: some configuration template template: src={{ item }} dest=/etc/file.cfg mode=0444 owner=root group=root with_first_found: - files: - &quot;{{inventory_hostname}}/etc/file.cfg&quot; paths: - ../../../templates.overwrites - ../../../templates - files: - etc/file.cfg paths: - templates","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}],"tags":[{"name":"ansible","slug":"ansible","permalink":"http://yoursite.com/tags/ansible/"},{"name":"运维","slug":"运维","permalink":"http://yoursite.com/tags/运维/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/后端/"}]},{"title":"前端UI框架","slug":"前端UI框架","date":"2018-07-24T10:51:12.000Z","updated":"2019-01-09T09:50:41.384Z","comments":true,"path":"2018/07/24/前端UI框架/","link":"","permalink":"http://yoursite.com/2018/07/24/前端UI框架/","excerpt":"","text":"BootstrapBootstrap，来自 Twitter，是目前最受欢迎的前端框架。Bootstrap 是基于 HTML、CSS、JAVASCRIPT 的，它简洁灵活，使得 Web 开发更加快捷。 Github：https://github.com/twbs/bootstrap 中文教程：http://www.bootcss.com/ Semantic-uiSemantic 是一个为主题化而设计的UI框架。主要特点：50+ UI 元素；3000 + CSS 变量；3 级变量继承(和 SublimeText 类似)；用 em 作为单位构建以实现响应式设计；Flexbox 友好。 官网：https://semantic-ui.com/ Github：https://github.com/Semantic-Org/Semantic-UI FoundationFoundation 是一个易用、强大而且灵活的框架，用于构建基于任何设备上的 Web 应用。提供多种 Web 上的 UI 组件，如表单、按钮、Tabs 等等。 官网：http://foundation.zurb.com/ Github：https://github.com/zurb/foundation-sites IviewiView 主要服务于 PC 界面的中后台业务，是一套高质量的开源 UI 组件库。主要特性：使用单文件的 Vue 组件化开发模式；基于 npm + webpack + babel 开发，支持 ES2015；高质量、功能丰富；友好的 API ，自由灵活地使用空间；详细、友好的文档，事无巨细。 官网：https://www.iviewui.com/ Github：https://github.com/iview/iview LayuiLayui 是一款采用自身模块规范编写的国产前端UI框架，遵循原生HTML/CSS/JS的书写与组织形式，门槛极低，拿来即用。其外在极简，却又不失饱满的内在，体积轻盈，组件丰盈，从核心代码到API的每一处细节都经过精心雕琢，非常适合界面的快速开发。 官网：http://www.layui.com/ Github：https://github.com/sentsin/layui FrozenuiFrozen UI是一个开源的简单易用，轻量快捷的移动端UI框架。基于手Q样式规范，选取最常用的组件， 做成手Q公用离线包减少请求，升级方式友好，文档完善，目前全面应用在腾讯手Q增值业务中。 官网：http://frozenui.github.io Github：https://github.com/frozenui/frozenui","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Python-读取文件","slug":"Python-读取文件","date":"2018-07-24T08:24:54.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/07/24/Python-读取文件/","link":"","permalink":"http://yoursite.com/2018/07/24/Python-读取文件/","excerpt":"","text":"获取当前路径def get_file_path(): # 获取脚本路径 path = sys.path[0] if os.path.isdir(path): return path elif os.path.isfile(path): return os.path.dirname(path) 读取文件item_object = open(item_txt_path, &quot;rU&quot;) try: for line in islice(item_object, 1, None): id_str = re.split(r&quot;\\t&quot;, line) id_list = {&apos;id&apos;: id_str[0], &apos;name&apos;: id_str[1]} self.idArr.append(id_list) finally: item_object.close() islice(item_object, 1, None)跳过第一行 github","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}]},{"title":"charles+android监听websocket","slug":"charles-android监听websocket","date":"2018-07-24T07:41:57.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/07/24/charles-android监听websocket/","link":"","permalink":"http://yoursite.com/2018/07/24/charles-android监听websocket/","excerpt":"","text":"设备环境charles版本4.0.1 小米6 android 8.0.0 安装证书 按照Charles的提示，手机打开 chls.pro/ssl 小米通过UC浏览器下载得到一个 charles-proxy-ssl-proxying-certificate.pem 证书 设置 &gt; 更多设置(系统和设备) &gt; 系统安全 &gt; 安装位置应用&gt;文件管理 注：小米通过自带浏览器（QQ浏览器或者其它浏览器未测）下载得到一个 getssl.crt 证书，安装不成功 charles监听安卓websocket3.11版本之后，开始支持websocket抓取，不知道什么原因，使用上面wifi代理配置，无法抓取到websocket请求，查了很多文章都没有成功，最后，看到一句话：有些协议不会经过wifi代理， 于是借助drony，设置步骤：进入setting选项卡，选择Wi-Fi：找到使用的网络名，点进去设置，设置为charles的地址地址和端口：修改系統代理設定WIFI代理設定, 進入你連接的WIFI網絡的內容:","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"charles","slug":"charles","permalink":"http://yoursite.com/tags/charles/"},{"name":"android","slug":"android","permalink":"http://yoursite.com/tags/android/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Git 常用命令","slug":"Git-常用命令","date":"2018-07-24T07:32:58.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/07/24/Git-常用命令/","link":"","permalink":"http://yoursite.com/2018/07/24/Git-常用命令/","excerpt":"","text":"Git global setupgit config --global user.name &quot;YourNames&quot; git config --global user.email &quot;YourMail&quot; Create a new repository git clone git@xxx.com:open/open.git cd open touch README.md git add README.md git commit -m &quot;add README&quot; git push -u origin master Existing folder or Git repository cd existing_folder git init git remote add origin git@xxx.com:open/open.git git add . git commit git push -u origin master 如何删除本地分支 git branch -d branch_name 如何删除远端分支 git push origin :branch_name 远端分支已经删除，本地还出现这个分支 git fetch origin -p 如何撤销上一次提交 高风险操作 git reset ^1 --hard","categories":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/tags/Git/"}],"keywords":[{"name":"Git","slug":"Git","permalink":"http://yoursite.com/categories/Git/"}]},{"title":"/usr/bin/pip: No such file or directory","slug":"usr-bin-pip-No-such-file-or-directory","date":"2018-07-24T07:30:20.000Z","updated":"2019-01-09T09:50:41.384Z","comments":true,"path":"2018/07/24/usr-bin-pip-No-such-file-or-directory/","link":"","permalink":"http://yoursite.com/2018/07/24/usr-bin-pip-No-such-file-or-directory/","excerpt":"","text":"应用pip时出现You are using pip version 9.0.1, however version 10.0.1 is available.问题，说明需要更新， 使用sudo -H pip install –upgrade pip命令更新成功之后，运行pip –version，得到-bash: /usr/bin/pip: No such file or directory； 执行which pip得到/usr/local/bin/pip，可见是出现了缓存问题， 执行hash -r可清除缓存，pip正常","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}]},{"title":"彻底关闭windows Defender","slug":"彻底关闭windows-Defender","date":"2018-07-24T07:27:45.000Z","updated":"2019-01-09T09:50:41.384Z","comments":true,"path":"2018/07/24/彻底关闭windows-Defender/","link":"","permalink":"http://yoursite.com/2018/07/24/彻底关闭windows-Defender/","excerpt":"","text":"windows Defender是win10自带的保护电脑的工具，当遇到安装的软件性能出现问题时，需验证是否是windows Defender的影响.关闭windows Defender （验证有效）： win加r搜索输入regedit进入注册表编辑器 找到‘HKEY_LOCAL_MACHINE’选项（左侧菜单栏第三个就是），打开。 接下来找到SYSTEM，然后打开第三个选项。 继续找‘CurrentControlSet’—‘Services’—‘SecurityHealthService’ 最后找到start时候打开，将里面数字2改为4重启即可永远关闭，开启重新改回2，再重启生效","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"windows10","slug":"windows10","permalink":"http://yoursite.com/tags/windows10/"},{"name":"windows defender","slug":"windows-defender","permalink":"http://yoursite.com/tags/windows-defender/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"IOS马甲包混淆必过4.3审核上线方法整理","slug":"IOS马甲包混淆必过4-3审核上线方法整理","date":"2018-07-24T07:24:41.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/07/24/IOS马甲包混淆必过4-3审核上线方法整理/","link":"","permalink":"http://yoursite.com/2018/07/24/IOS马甲包混淆必过4-3审核上线方法整理/","excerpt":"","text":"相关参考链接 https://zhuanlan.zhihu.com/p/38481422 https://www.jianshu.com/p/871dda4f5dca https://www.jianshu.com/p/37db5b67704a https://www.jianshu.com/p/eb3069bcba52 https://blog.csdn.net/lyzz0612/article/details/80390362 https://blog.csdn.net/kuaileboer/article/details/80030930","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"http://yoursite.com/tags/IOS/"},{"name":"审核","slug":"审核","permalink":"http://yoursite.com/tags/审核/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Dash","slug":"Dash","date":"2018-07-24T07:19:36.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/07/24/Dash/","link":"","permalink":"http://yoursite.com/2018/07/24/Dash/","excerpt":"","text":"Mac下文档搜索工具 下载地址： Dash+4+for+Mac+4.0.3.dmg 提取密码： sndc 解压密码: www.ifunmac.com","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Dash","slug":"Dash","permalink":"http://yoursite.com/tags/Dash/"},{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Alfred","slug":"Alfred","date":"2018-07-24T07:11:48.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/07/24/Alfred/","link":"","permalink":"http://yoursite.com/2018/07/24/Alfred/","excerpt":"","text":"简介Mac下高效率启动工具 下载地址Alfred+3+for+Mac+3.3.2.dmg解压密码为www.ifunmac.com","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Alfred","slug":"Alfred","permalink":"http://yoursite.com/tags/Alfred/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"浏览器翻墙工具","slug":"浏览器翻墙工具","date":"2018-07-23T12:54:53.000Z","updated":"2019-01-09T09:50:41.384Z","comments":true,"path":"2018/07/23/浏览器翻墙工具/","link":"","permalink":"http://yoursite.com/2018/07/23/浏览器翻墙工具/","excerpt":"","text":"Chrome浏览器自动翻墙插件 通过附件或者Github下载插件，导入附件内的配置备份，在浏览器中插件界面配置为自动切换模式即可无缝打开google等网站。 下载地址 SwitchyOmega.crx 配置备份 OmegaOptions.bak 配置说明文档 https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"Chrome","slug":"Chrome","permalink":"http://yoursite.com/tags/Chrome/"},{"name":"翻墙","slug":"翻墙","permalink":"http://yoursite.com/tags/翻墙/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}]},{"title":"Hexo新建页面显示多个文章","slug":"Hexo新建页面显示多个文章","date":"2018-07-23T10:58:48.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/07/23/Hexo新建页面显示多个文章/","link":"","permalink":"http://yoursite.com/2018/07/23/Hexo新建页面显示多个文章/","excerpt":"","text":"配置categories1.生成post(文章)时默认生成categories配置项：在根目录下scaffolds/post.md中，添加一行categories:。同理可应用在page.md和photo.md，示例如下： --- title: {{ title }} date: {{ date }} tags: [&apos;标签1&apos;,&apos;标签2&apos;] categories: [&apos;前端&apos;] comments: false // 是否开启评论 img: // 自定义缩略图 --- 2.在实际写作时，在开头进行categories配置。例如： --- title: Hexo新建页面显示多个文章 tags: - 标签1 - 标签2 categories: - 前端 comments: false // 是否开启评论 img: // 自定义缩略图 date: 2018-07-23 18:58:48 --- 这样在文章发布时，在git中使用hexo g命令，hexo会在根目录/public/categrises下自动生成归档文件夹，如图： 3.配置博客首页归档展示样式。在主题配置文件themes/_config.yml中添加以下代码: menu: - page: home url: / icon: fa-home - page: 前端 url: /categories/前端 icon: - page: 后端 url: /categories/后端 icon: - page: 工具 url: /categories/工具 icon: - page: 分类 url: /category/ icon: - page: 时间轴 url: /archives/ icon: 补充说明如果发现博客首页展示文本为英文，需要改为中文显示，需要修改先博客根目录下的_config.yml文件的language配置，示例如下： # Site title: 借我一支烟 subtitle: 个人博客 description: keywords: author: Lin language: zh-CN timezone: 然后为实现文章归档名称显示为中文，接着再修改主题配置文件下language/zh-CN.yml即可，示例如下： read_more: 阅读全文 home: 首页 about: 关于我 archives: 归档 引用本地图片不显示 究其原因，是图片路径出现问题。 Hexo图片引用有他的方式，部署以后，图片会自动添加日期相关的文件结构目录。 解决方法 _config.yml 文件中设置 post_asset_folder: true，开启资源文件夹功能，该功能支持用户通过相对路径标签引用资源。执行 hexo new [layout] 创建一篇新的文章，会发现 source/_posts 下自动生成了一个和 md 文件同名的目录（也可以自己手动创建），这就是用于存放与文章有关的图片文件夹。如下图： 部署之后同目录出现 需要注意的是，使用该种方式在 markdown 文件中引用图片将不再使用 markdown 语法，而是使用标签插件引用相对路径，否则可能造成图片和其他资源显示不正确。引用语法如下： {% asset_path slug %} {% asset_img slug [title] %} {% asset_link slug [title] %} 在上述语法下，插入图片的方法： {% asset_img image.png This is an example image %} 查看页面，发现图片已经可以正常显示了，图片的路径和实际存放目录是一致的。如果想使用 markdown 语法插入相对路径的图片，可以利用插件。设置 post_asset_folder:true 后，在根目录下执行： npm install https://github.com/CodeFalling/hexo-asset-image --save 确保在 source/_posts 下创建和 markdown 文件同名的目录，里面存放需要的图片，然后在 markdown 中插入图片： ! [hexo image] (hexo/image.png) 生成的页面中图片引用路径 &lt;img src=&quot;/2016/11/25/hexo/image.png&quot; alt=&quot;hexo image&quot;&gt; 至此，用 markdown 完美实现本地图片插入。","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Markdown 语法说明 (简体中文版)","slug":"Markdown","date":"2018-07-20T12:47:03.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/07/20/Markdown/","link":"","permalink":"http://yoursite.com/2018/07/20/Markdown/","excerpt":"","text":"链接地址：http://wowubuntu.com/markdown/#link 简书 说明： 引用是在名词前加4个空格，并且有空行","categories":[],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"}],"keywords":[]},{"title":"利用Hexo搭建自己的博客","slug":"Hexo-Blog","date":"2018-07-20T12:47:03.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/07/20/Hexo-Blog/","link":"","permalink":"http://yoursite.com/2018/07/20/Hexo-Blog/","excerpt":"","text":"原理GitHub会为每一个注册用户分配一个300M的个人空间，所以和hexo结合起来，利用github给我们的免费空间， 将我们的静态网页托管到上面，就实现了一个免费的搭建个人博客的方案。 主要设计名词 Git Hexo Node.js npm Markdown VS Code 主要步骤注册GitHub帐号，新建代码仓库 登录GitHub网站，注册一个帐号 新建一个代码仓库 填写仓库信息，其中仓库名称必须和用户名一样 环境配置 安装git。由于我使用的是MAC OS系统，自带了git功能，如果是其他系统，安装一个git客户端软件即可 安装Node环境，Hexo就是基于Node的，访问速度特别快。进入node.js官网，选对操作系统，安装即可 安装Hexo，初始化博客git和node环境安装好了以后。接下来就可以安装hexo了，直接在命令行中敲入如下代码： npm install -g hexo-cli 接下来建站 hexo init &lt;folder&gt; # 初始化博客，&lt;文件夹名称&gt;，表示文件会下载到当前目录下的这个文件夹内 cd &lt;folder&gt; # 进入到这个文件夹目录 npm install # 安装npm 使用相关编辑器打开这个文件夹中的文件夹，我是用的是VS Code 本地预览hexo server # 开启本地服务器 然后在浏览器里面输入网址http://localhost:4000，就能看到默认主题的界面 这是因为初始化hexo的时候就已经把一个能够起小型的网路服务器功能的依赖装好了，所以启动一下这个本地服务，就能看到hexo的默认主题 上传到远程代码仓库接下来就要将本地的代码上传到远程github仓库。首先建立和之前新建的代码仓库之间的关联，利用ssh key，具体是先用命令行在本地生成一个ssh key，然后复制到github上去。 一. 先检查本地有没存在ssh key ls -al ~/.ssh # 列出在.ssh文件夹下所有的文件，如果存在这个文件夹或者这些文件的话 二. 生成新的ssh key ssh-keygen -t rsa -C &quot;your_email@example.com&quot; # 注意将`your_email`替换成之前注册github帐号时的邮箱 生成成功或已经存在的，进入到~/.ssh/路径下，用文件编辑器打开文件，里面的内容就是ssk key，将内容复制到剪切板 登录GitHub网站,依次点击Settings –&gt; SSH and GPG keys –&gt; New SSH key，进入新建SSK key页面，随便填写一下Title,然后将剪切板中复制好的ssh key复制到key中去，最后点击Add SSH key按钮，就OK了 用VSCode打开博客主目录，找到主目录在的_config.yml文件，编辑这个文件，找到最下方deployment模块（顺便找到Site模块，修改一下博客的titile，subtitle，author，改成你自己个性化的），将deployment模块里面的代码替换为如下： deploy: type: git repository: https://github.com/用户名/用户名.github.io.git # 将用户名替换为你自己的github用户名 branch: master 特别提醒：每个分号:后都要有一个空格，不然接下来生成和部署博客到github上时会报下面这种错误： JS-YAML: bad indentation of a mapping entry at line , column 三. 进到博客根目录下，先执行 hexo generate # 或者：hexo g 生成静态页面至public目录 如出现报错 ERROR Local hexo not found in ~/blog ERROR Try runing: &apos;npm install hexo --save&apos; 则执行： npm install hexo --save 再执行： hexo deploy # 或者：hexo -g 将.deploy目录部署到GitHub 如果无法连接到git,则执行： npm install hexo-deployer-git --save # 安装hexo-deployer-git 最后再执行： hexo g hexo d 四. 进到浏览器，打开http://用户名.github.io网址，就可以看到和之前本地看到的hexo默认主题的首页，看到你修改好的博客title，subtitle，author，等。至此，和github的关联已经建立好，接下来就可以写博客了 写博客写博客主要使用到几个命令： hexo new &quot;postName&quot; # 新建文章 默认在\\source\\_posts\\postName.md文件夹下 hexo new page &quot;pageName&quot; #新建页面，如关于我界面 新建后，在source文件目录下生成一个以postName命名的.md文件，直接用markdown语法编辑，写文章就是这么简单。hexo可以将markdown语法的文件渲染成静态的HTML。关于markdown语法，非常简单，上手很快，可以上网去搜一下语法Markdown 语法说明 (简体中文版) hexo clean # 删除之前生成的public文件夹和缓存数据 hexo g # 重新生成博客文件 hexo d # 将修改同步到github远程仓库 换主题，个性化配置 更换主题进入hexo相关主题展示的theme网站,选取一款你喜欢的主题。将你喜欢的主题clone到themes文件夹下，我选的是jacman主题，直接编辑主目录下的_config.yml配置文件，找到theme,将默认的主题换成你喜欢的主题名即可 配置主题样式换完主题后，就可以修改主题样式了，主要修改主配置文件_config.yml以及主题文件下的配置文件_config.yml。 添加第三方评论系统 使用disqus,直接注册，然后获取到duoshuo_shortname，填到jacman主题下面配置文件_config.yml对应的地方，第三方评论系统就安装好了 参考文章利用 GitHub Pages 快速搭建个人博客我的个人技术博客搭建之旅","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/前端/"}]},{"title":"Python--配置虚拟环境","slug":"Python-配置虚拟环境","date":"2018-07-20T12:24:15.000Z","updated":"2019-01-09T09:50:41.368Z","comments":true,"path":"2018/07/20/Python-配置虚拟环境/","link":"","permalink":"http://yoursite.com/2018/07/20/Python-配置虚拟环境/","excerpt":"","text":"安装虚拟环境 打开终端,利用pip/pip3 安装 (pip安装在python2,pip3安装在python3中) 执行：sudo pip install virtualenv 创建环境 virtualenv 环境名 例： 1. mkdir ~/py_envs # 在用户目录下创建了一个统一管理虚拟环境的目录 2. cd ~/py_envs # 跳进这个目录 3. virtualenv env_workspace1 # 创建一个虚拟工作空间 创建指定python版本的环境 virtualenv venv –python=python2.7 激活环境（切换到新环境目录） 执行：source ./bin/activate 例: cd env_workspace1 # 进入虚拟环境 source bin/activate # 激活虚拟环境 使用环境 （接下来直接pip安装需要的插件） 注意！不要加sudo，否则会安装到系统环境中，没有安装到虚拟环境中执行：pip install xxx 例： pip install flask pip install django pip install Scipy 退出环境 deactivate 删除环境 （需要在退出环境之后才能操作） rmvirtualenv 环境名","categories":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/前端/"},{"name":"Python","slug":"Python","permalink":"http://yoursite.com/tags/Python/"}],"keywords":[{"name":"Python","slug":"Python","permalink":"http://yoursite.com/categories/Python/"}]}]}